#pragma once

#include <string>

namespace ub_tester::clio::internal::consts {

inline const std::string ManagerName = "AssertMessageManager.h";
inline const std::string ManagerInStringBeforeFlags = "#pragma once\n\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <cassert>\n\n#define PUSH_ERROR(FailCode, Message)                                                                                            \\ \n  std::cerr << (Message) << ' ' << static_cast<int>(AssertFailCode::FailCode) << std::endl;                                      \\ \n  AssertMessageManager::pushMessage(AssertMessage((Message), AssertFailCode::FailCode));                                         \\ \n  assert(0 && \"Assert detected error but manager didn't handle it\")\n#define PUSH_WARNING(FailCode, Message)                                                                                          \\ \n  AssertMessageManager::pushMessage(AssertMessage(\"warning! \" + (Message), AssertFailCode::FailCode))\n\nnamespace ub_tester::assert_message_manager::supress_messages_mode {\n\n";
inline const std::string ManagerSuppressAllOutputFlagVariable = "constexpr bool SUPRESS_ALL"; // = false;
inline const std::string ManagerSuppressWarningsFlagVariable = "constexpr bool SUPRESS_WARNINGS"; // = false;
inline const std::string ManagerInStringAfterArgs = "\nconstexpr bool SUPRESS_ARITHM_WARNINGS = false;\nconstexpr bool SUPRESS_UNSIGNED_OVERFLOW_WARNING = false;\nconstexpr bool SUPRESS_OVERFLOW_IN_BITSHIFT_CXX20_WARNING = false;\nconstexpr bool SUPRESS_UNSAFE_CONV_WARNING = false;\nconstexpr bool SUPRESS_IMPL_DEFINED_UNSAFE_CONV_WARNING = false;\n\nconstexpr bool SUPRESS_UNINIT_VARS_WARNINGS = false;\n// constexpr bool SUPRESS_IOB_WARNINGS = false;\n\nconstexpr bool SUPRESS_IMPL_DEFINED_WARNING = false;\nconstexpr bool SUPRESS_NOT_CONSIDERED_WARNING = false;\n\n}; // namespace ub_tester::assert_message_manager::supress_messages_mode\n\nnamespace ub_tester::assert_message_manager {\n\nenum class AssertFailCode { // error code > 0, warning code < 0\n  OVERFLOW_ERROR = 1,\n  DIVISION_BY_ZERO_ERROR = 2,\n  UNDEFINED_MOD_ERROR = 3,\n  UNDEFINED_BITSHIFT_LEFT_ERROR = 4,\n  UNDEFINED_BITSHIFT_RIGHT_ERROR = 5,\n  UNINIT_VAR_ACCESS_ERROR = 20,\n\n  UNSIGNED_OVERFLOW_WARNING = -1,\n  OVERFLOW_IN_BITSHIFT_CXX20_WARNING = -2,\n  IMPL_DEFINED_WARNING = -3,\n  UNSAFE_CONV_WARNING = -4,\n  IMPL_DEFINED_UNSAFE_CONV_WARNING = -5,\n  NOT_CONSIDERED_WARNING = -6,\n  UNINIT_VAR_IS_NOT_TRACKED_ANYMORE_WARNING = -20\n};\n\nstruct AssertMessage final {\n  AssertMessage(std::string Message, AssertFailCode FailCode) : Message_{Message}, FailCode_{FailCode} {}\n  std::string Message_;\n  AssertFailCode FailCode_;\n};\n\nbool checkIfMessageIsSupressed(AssertFailCode FailCode) {\n  using namespace supress_messages_mode;\n  if (SUPRESS_ALL)\n    return true;\n  if (SUPRESS_WARNINGS && static_cast<int>(FailCode) < 0)\n    return true;\n\n  switch (FailCode) {\n  // arithm errors\n  case AssertFailCode::OVERFLOW_ERROR:\n    return false;\n  case AssertFailCode::DIVISION_BY_ZERO_ERROR:\n    return false;\n  case AssertFailCode::UNDEFINED_MOD_ERROR:\n    return false;\n  case AssertFailCode::UNDEFINED_BITSHIFT_LEFT_ERROR:\n    return false;\n  case AssertFailCode::UNDEFINED_BITSHIFT_RIGHT_ERROR:\n    return false;\n  // uninit-vars error\n  case AssertFailCode::UNINIT_VAR_ACCESS_ERROR:\n    return false;\n  // arithm warnings\n  case AssertFailCode::UNSIGNED_OVERFLOW_WARNING:\n    return SUPRESS_UNSIGNED_OVERFLOW_WARNING || SUPRESS_ARITHM_WARNINGS;\n  case AssertFailCode::OVERFLOW_IN_BITSHIFT_CXX20_WARNING:\n    return SUPRESS_OVERFLOW_IN_BITSHIFT_CXX20_WARNING || SUPRESS_ARITHM_WARNINGS;\n  case AssertFailCode::IMPL_DEFINED_WARNING:\n    return SUPRESS_IMPL_DEFINED_WARNING || SUPRESS_ARITHM_WARNINGS;\n  case AssertFailCode::UNSAFE_CONV_WARNING:\n    return SUPRESS_UNSAFE_CONV_WARNING || SUPRESS_ARITHM_WARNINGS;\n  case AssertFailCode::IMPL_DEFINED_UNSAFE_CONV_WARNING:\n    return SUPRESS_IMPL_DEFINED_UNSAFE_CONV_WARNING || SUPRESS_ARITHM_WARNINGS;\n  case AssertFailCode::NOT_CONSIDERED_WARNING:\n    return SUPRESS_NOT_CONSIDERED_WARNING || SUPRESS_ARITHM_WARNINGS;\n  // uninit-vars warning\n  case AssertFailCode::UNINIT_VAR_IS_NOT_TRACKED_ANYMORE_WARNING:\n    return SUPRESS_UNINIT_VARS_WARNINGS;\n  }\n  assert(0 && \"Undefined AssertFailCode\");\n}\n\nclass AssertMessageManager final {\nprivate:\n  AssertMessageManager() = default;\n\n  void handleMessage(AssertMessage Message) {\n    if (!checkIfMessageIsSupressed(Message.FailCode_))\n      Messages_.push_back(std::move(Message));\n    if (static_cast<int>(Message.FailCode_) > 0) // if error\n      printMessagesNTerminate(Message.FailCode_);\n  }\n\n  void printMessagesNTerminate(AssertFailCode FailCode) {\n    for (const auto& Message : Messages_)\n      std::cerr << Message.Message_ << \"\\n\";\n    Messages_.clear();\n    if (!supress_messages_mode::SUPRESS_ALL)\n      std::cerr << \"error detected, aborting\\n\\n\";\n    exit(static_cast<int>(FailCode));\n  }\n\npublic:\n  ~AssertMessageManager() {\n    for (const auto& Message : Messages_)\n      std::cerr << Message.Message_ << \"\\n\";\n  }\n\n  static AssertMessageManager& getInstance() {\n    if (!ManagerPtr_)\n      ManagerPtr_ = std::unique_ptr<AssertMessageManager>(new AssertMessageManager{});\n    return *ManagerPtr_;\n  }\n\n  static void pushMessage(AssertMessage Message) { AssertMessageManager::getInstance().handleMessage(std::move(Message)); }\n\nprivate:\n  static std::unique_ptr<AssertMessageManager> ManagerPtr_;\n  std::vector<AssertMessage> Messages_{};\n};\n\ninline std::unique_ptr<AssertMessageManager> AssertMessageManager::ManagerPtr_ = nullptr;\n\n} // namespace ub_tester::assert_message_manager\n";

}